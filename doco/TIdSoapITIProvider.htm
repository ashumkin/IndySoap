<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<title>TIdSoapITIProvider</title>
		<style>@import url(indysoap.css); 
	</style>
	</head>
	<body>
		<h2>TIdSoapITIProvider</h2>
		Unit: IdSoapITIProvider
		<p>
			TIdSoapITIProvider provides base level functionality shared between client and 
			server. These consist of:
		</p>
		<ul>
			<li>
			SOAP configuration
			<li>
			SOAP packet access
			<li>
				ITI (Interface Type Information) Provision
			</li>
		</ul>
		<h4>SOAP Configuration</h4>
		<p>&nbsp;</p>
		<pre>Property Active : boolean; </pre>
		<p>
			Defines whether Component is active or not. Soap Clients and servers will only 
			function when tey are active. Many properties for configuring the client and 
			server cannot be changed while they are active. Once the Soap component has 
			been configured, you must start the component by setting Active := True
		</p>
		<p>&nbsp;</p>
		<pre>property DefaultNamespace : string;</pre>
		<p>The namespace used for any SOAP or WSDL encoding if no namespace is associated 
			directly with the interface in the ITI. All soap and WSDL XML encoding requires 
			an XML namespace. The choice of namespace is purely arbitrary but both client 
			and server must use the same namespace in order to communicate. Namespaces can 
			be associated with Interfaces directly. This is the preferred method for 
			defining namespaces, and the IndySoap WSDL -&gt; pascal wizard will define the 
			namespace at this point. When no namespace has been associated with the 
			interface, this namespace will be used.&nbsp;<i>You shouldn't need to change this 
				value if you are using IndySoap as both client &amp; server, or if the 
				interface was generated by the IndySoap WSDL -&gt; Pascal wizard.</i>
		</p>
		<P>&nbsp;</P>
		<PRE>property XMLProvider: TIdSoapXMLProvider;</PRE>
		<P>The actual XML library provided when using XML. The following options are 
			currently valid:</P>
		<P>
			<TABLE id="Table3" cellSpacing="1" cellPadding="1" width="90%" border="1">
				<TR>
					<TD>Value</TD>
					<TD>Comments</TD>
				</TR>
				<TR>
					<TD>xpOpenXML</TD>
					<TD>OpenXML. OpenXML comes bundled with IndySoap and this is the default value. 
						Unless there is a specific reason, this is the best choice</TD>
				</TR>
				<TR>
					<TD>xpMsXML</TD>
					<TD>MsXML is provided so that applications can integrate downstream XML handling 
						with the XML from the SOAP packets. Unless you know why you want to do this, 
						you shouldn't use MsXML, since it is slower and must be installed with your 
						application</TD>
				</TR>
				<TR>
					<TD>xpCustom</TD>
					<TD>
						<P>The Custom XML provider is provided for speed. It is not complete nor standards 
							compliant, not should it be relied on for coherent error messages. It should 
							function with most RPC based SOAP applications. You should only use this where 
							performance is a genuine concern. The following XML features are not supported 
							by the custom provider:</P>
						<UL>
							<LI>
							XML comments
							<LI>
							XML processing instructions other than the first one
							<LI>
							CData sections
							<LI>
							mixed content
							<LI>
							most DOM functionality&nbsp;
							<LI>
								UTF-16, other non-ascii context types</LI></UL>
					</TD>
				</TR>
			</TABLE>
			&nbsp;</P>
		<P>Roughly, the custom provider is twice as fast as OpenXML, which is twice as fast 
			as MsXML. (this should not be taken as a general benchmark - this is 
			specifically for the functions used by IndySoap). Also note that only about 25% 
			of the overall indysoap processing time is taken up with XML handling, so this 
			doesn't make that much difference to performance</P>
		<P>&nbsp;</P>
		<pre>property EncodingType: TIdSoapEncodingType;</pre>
		<p>Defines which encoding scheme will be used by the Soap Components when building 
			Soap packets
		</p>
		<ul>
			<li>
				<b>etIdAutomatic </b>Allow Component to choose best available encoding scheme
				<br>
				Client: choose based on transport layer (usually XML-utf-8)
				<br>
			Server: use same encoding as client
			<li>
				<b>etIdBinary </b>
			Use proprietary binary encoding scheme. This is a fast encoding scheme that 
			reuqires IndySoap at both ends
			<li>
				<b>etIdXmlUtf8 </b>
			Standard SOAP encoding using utf-8
			<li>
				<b>etIdXmlUtf16 </b>Standard SOAP encoding using utf-16
			</li>
		</ul>
		<p>&nbsp;</p>
		<pre>property EncodingOptions : TIdSoapEncodingOptions; </pre>
		<p>
			The encoding options control the way in which IndySoap reads and writes 
			packets. Each encodingOption may only apply for a particular combination of 
			Soap Mode (RPC vs Doc|Lit) and (reading vs writing).
		</p>
		<p>
			Possible Options (a set of these options):
		</p>
		<UL>
			<li>
				<b>seoUseCrLf</b>
				<br>
				Applies: Reading
				<br>
			The XML standard requires eol's to be encoding using #10. If this is selected, 
			then string #10's will be converted to #13#10 after reading. This only applies 
			to ANSI Strings and Chars, Not widechars or Widestrings
			<li>
				<b>seoCheckStrings</b>
				<br>
				Applies: Writing
				<br>
			If this is selected, then chars &amp; strings will be prescanned to check that 
			none of the characters are out of range. Using XML encoding it's not safe to 
			send these but it is usually safe to send them using the Binary encoding
			<li>
				<b>seoReferences</b>
				<br>
				Applies: Writing
				<br>
			If this is selected, then objects will be encoded using references, this allows 
			a single object to be used more than once and the resulting structure being 
			represented at the other end as a single object. Note that the SOAP Spec 
			strongly recommends the use of References
			<li>
				<b>seoCheckMustUnderstand</b>
				<br>
				Applies: Reading<br>
			If this is selected, then incoming messages will be checked for MustUnderstand 
			headers, and the message will be rejected if any are found. By default, this is 
			not selected, and the mustUnderstand attribute is ignored. The application can 
			check the headers itself it it needs to
			<li>
				<b>seoRequireTypes</b>
				<br>
				Applies: Reading when not in Doc|Lit mode&nbsp;<br>
			if this is selected, then IndySoap will require a precise match between the 
			pascal type it expects and the corresponding *Stated* schema type. If this is 
			not selected, then a conversion will attempted as best as possible. This is 
			selected by default since it provides better type checking and more informative 
			messages, and works with most RPC SOAP libraries
			<li>
				<b>seoSuppressTypes</b>
				<br>
				Applies: Writing packets, when not in Doc|Lit mode&nbsp;<br>
			if this is selected, then IndySoap will not indicate element types in the soap 
			message. Only use this if you have to.&nbsp;
			<li>
				<STRONG>seoArraysAnyNamespace<BR>
				</STRONG>
			Some soap systems do not put arrays in the soap encoding namespace. This is 
			wrong, but the reader will treat any node with a name "Array"&nbsp;as an array 
			if this option is selected. (Note: this still won't solve all interoperability 
			problems as there are systems out there with bigger problems than the 
			namespace). This option only applies to RPC soap
			<LI>
				<STRONG>seoArraysInLine</STRONG><BR>
			Set this to true if the soap system at the other end encodes&nbsp;arrays 
			in-line rather than using the Soap Array Construct. (This is the default in 
			doc|lit mode. It's unusual to need this option - usually you would use doc|lit 
			mode if you needed in-line arrays)
			<LI>
				<B>seoSendCharset</B>
				<br>
				Applies: Writing packets&nbsp;<br>
			if this is selected, then IndySoap will append the charset type to the 
			content-type when sending the message. Some servers insist on this, others do 
			not accept it
			<LI>
				<STRONG>seoDimeEncoding</STRONG><BR>
			by default, IndySoap will use normal soap, and DIME if there is any 
			attachments. Set seoDimeEncoding if you want DIME encoding used all the time. 
			(Not fully supported yet)
			<LI>
				<STRONG>seoUseDefaults</STRONG><BR>
				if this option is set, IndySoap will not require XML elements for all 
				parameters, and will provide a default value if the element is not present. For 
				simple types, you won't be able to determine whether the value was actually 
				sent or not. If this is a problem then use the TIdSoapSimpleClass system. Char 
				is not affected by this option - there can be no default value for char (and 
				widechar)
				<BR>
			This only applies in XML when reading (see seoSendNoDefaults for writing)
			<LI>
				<STRONG>seoUseNullForNil</STRONG><BR>
			support old versions of apache. They require xsi:null instead of xsi:nil even 
			when the schema location is given as the 2001 location (fixed in the 2.3 
			release of Apache SOAP)
			<LI>
				<STRONG>seoSendNoDefaults</STRONG>
				<BR>
				when a packet is being built, specifies whether the default values will 
				be&nbsp;sent or not. If this is set, then values that match the default values 
				will not be sent in the message. Default Values:
				<BR>
				&nbsp;&nbsp; String, AnsiString, wideString : ''
				<BR>
				&nbsp;&nbsp; ordinal types - 0 if a parameter or a property with
				<BR>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; no nominated default value, otherwise the 
				value of the nominated default
				<BR>
				&nbsp;&nbsp; other types - no default
			</LI>
		</UL>
		<h4>SOAP Packet Access</h4>
		<span style="FONT-FAMILY: courier new,courier,monospace">Type</span><br style="FONT-FAMILY: courier new,courier,monospace">
		<span style="FONT-FAMILY: courier new,courier,monospace">&nbsp;
TIdViewMessageEvent = procedure (ASender : TIdSoapITIProvider; AMessage
: TStream) of object; </span><br style="FONT-FAMILY: courier new,courier,monospace">
		<span style="FONT-FAMILY: courier new,courier,monospace">&nbsp;
TIdViewMessageDomEvent = procedure (ASender : TIdSoapComponent; ADom :
TIdSoapXmlDom) of object;</span><br style="FONT-FAMILY: courier new,courier,monospace">
		<br style="FONT-FAMILY: courier new,courier,monospace">
		<span style="FONT-FAMILY: courier new,courier,monospace">&nbsp;
property OnReceiveMessage :&nbsp; TIdViewMessageEvent;</span><br style="FONT-FAMILY: courier new,courier,monospace">
		<span style="FONT-FAMILY: courier new,courier,monospace"> 		&nbsp;
property OnSendMessage :&nbsp; TIdViewMessageEvent; 		</span><br style="FONT-FAMILY: courier new,courier,monospace">
		<span style="FONT-FAMILY: courier new,courier,monospace">&nbsp;
property OnReceiveMessageDOM :&nbsp; TIdViewMessageDOMEvent;</span><br style="FONT-FAMILY: courier new,courier,monospace">
		<span style="FONT-FAMILY: courier new,courier,monospace"> 		&nbsp;
property OnSendMessageDOM :&nbsp; TIdViewMessageDOMEvent;</span><br style="FONT-FAMILY: courier new,courier,monospace">
		<span style="FONT-FAMILY: courier new,courier,monospace">&nbsp;
property OnSendExceptionDOM :&nbsp; TIdViewMessageDOMEvent;</span>
		<p>These events exist to allow the application raw access to the actual SOAP 
			packets as a stream or as a DOM. Applications can use these events to log the 
			soap messages (i.e. for debugging), or to manipulate the messages (i.e. by 
			using transforms or manipulating the DOM).
			<br>
		</p>
		<p>It's safe to replace the contents of the stream. The stream position will be 
			reset to position 0 by IndySoap after this event is called. On the 
			server,&nbsp;any event handler catching these events should be thread safe
		</p>
		<p></p>
		<p>
		</p>
		<h4>Session Management</h4>
		<p>IndySoap includes a <a href="SessionManagement.htm">session management layer</a>. 
			These proprties configure the way that a&nbsp;client or server supports 
			sessions.</p>
		<pre>  property SessionSettings.SessionType : TIdSoapSessionPolicy;</pre>
		<p>Whether the client or server supports Sessions, and how the session information 
			is carried on the wire. Possible values are:</p>
		<ul>
			<li>
			sspNoSessions: No sessional behaviour
			<li>
			sspSoapHeaders: Sessions are supported, and session information is carried in 
			the SOAP Headers
			<li>
				sspCookies: Sessions are supported, and Session information is carried in HTTP 
				cookies</li>
		</ul>
		<p>Using SOAP Headers is preferred over using cookies, since it will work with any 
			transport&nbsp;layer, and can be represented in the WSDL. Cookies may be 
			mandated by interoperability considerations. If you use SoapHeaders, the 
			headers will automatically be declared in the WSDL</p>
		<p>&nbsp;</p>
		<pre>  property SessionSettings.MagicName : string;</pre>
		<p>If sessions are active, the name of the SOAPHeader or Cookie that carries the 
			session information on the wire.</p>
		<pre><br>  property SessionSettings.AutoAcceptSessions : boolean;</pre>
		<p>Controls whether the client or server will automatically accept a session if it 
			receives a packet that establishes (on client) or refers to (on server)&nbsp;a 
			session. By default, this is false. Typically, the server would create the 
			session, so this value would be false for the server and true for the client</p>
		<p>&nbsp;</p>
		<pre>Type<br>&nbsp; TIdSoapSessionEvent = procedure (ASender : TIdSoapITIProvider; ASession : TIdSoapSession) of object;&nbsp;</pre>
		<PRE>
		&nbsp; property OnCloseSession : TIdSoapSessionEvent;
		<br>&nbsp; property OnCreateSession : TIdSoapSessionEvent; </PRE>
		<p>These events are called&nbsp;when a session is created or destroyed.&nbsp;These 
			events are called whether the session is created or destroyed automatically as 
			a result of a SOAP packet, or manually by the application.&nbsp;</p>
		<h4>ITI Properties</h4>
		<p>All operational IndySoap interfaces require an ITI to function. The ITI must be 
			prepared before it is required by the ITI manager. The ITI generation is driven 
			by a&nbsp;&nbsp;<a href="Tools_IdSoapCfg.htm">IdSoapCfg Script</a>, either 
			executed manually using the InySoap Tools, or automatically by the <a href="Tools_DesignPackage.htm">
				IndySoap Design Package</a>.
		</p>
		<pre>  property.ITISource : TIdITISourceLocation;</pre>
		<p>Defines where the source should be found. Possible values:</p>
		<ul>
			<li>
				<strong>islNotDefined</strong> - Default setting;
				<br>
			not valid - setting active to true will fail&nbsp;
			<li>
				<strong>islFile</strong>&nbsp;<br>
			The source is a file. The filename is specified in the ITIFilename property. If 
			this is blank, the OnGetITIFilename event will be used&nbsp;
			<li>
				<strong>islEvent</strong>&nbsp;<br>
			Just call the OnGetITIStream, and the application will provide the ITI&nbsp;
			<li>
				<strong>islResource</strong>&nbsp;<br>
			Load the ITI from the Resource named in ITIResourceName&nbsp;
			<li>
				<strong>islRTTI</strong>&nbsp;<br>
				Build the RTTI on the fly from delphi RTTI. This is only valid under D6 
				enterprise, and you must have the define VER140ENTERPRISE defined in 
				IdSoapDefines.Inc</li>
			<li>
				<strong>islManual</strong>&nbsp;<br>
				Event OnLoadITI is called, program will manually handle loading the ITI 
                                (Usually reserved for loading ITI from multiple sources</li>
		</ul>
		<p>&nbsp;</p>
		<pre><pre>type </pre><pre>  TIdGetITIFileNameEvent = procedure(ASender: TIdSoapITIProvider; var VFileName: String) of object; </pre><pre><br><br>  property OnGetITIFileName : TIdGetITIFileNameEvent;</pre>  property ITIFileName:string; </pre>
		<p>
			ITIFileName is the Location of file that ITI will be loaded from. Only used if 
			ITISource is islFile. If no path is included in the filename, the filename is 
			relative to the current directory. If the filename is blank and ITISource is 
			islFile,&nbsp;the OnGetITIFilename event will be called instead
		</p>
		<p>&nbsp;</p>
		<pre>  property ITIResourceName:string;</pre>
		<p>When the ITI is loaded from the resource (ITISource = islResource), this is the 
			name of the resouce. The name of the resource is specified in the .IdSoapCfg 
			file that controlled the generation of the ITI resource. If no name is 
			specified in the IdSoapCfg file, then the name is the name of the resource file 
			(without the extension). You must include the resource file in the executable 
			using a {$R filename}
		</p>
		<p>When the ITISource ITISource = islManual, and the OnLoadITI event points to LoadMultipleResources, 
                        this is a comma separated list of resource names.
		</p>
		<p>&nbsp;</p>
		<pre>  property RTTINamesType : TIdRTTINamesType;<br>  property RTTINames : TStrings;</pre>
		<p>Summary: Defines a list of interfaces to include or exclude from the ITI when 
			the ITISource is islRTTI. Whether the names are include based or exclude based 
			depends on the property RTTINamesType, which can be rntExclude 
			or&nbsp;rntInclude</p>
		<pre>Type<br>  TIdGetITIStreamEvent = procedure(ASender: TIdSoapITIProvider; var VStream: TStream; var VFreeStream: Boolean) of object; </pre>
		<pre>&nbsp; property OnGetITIStream : TIdGetITIStreamEvent;</pre>
		<p>Summary: Get a stream containing the ITI when ITISource = islEvent. If 
			VFreeStream is true, then&nbsp;IndySoap will free the stream
		</p>
		<p><br>
			&nbsp;
		</p>
		<pre>Type<br>  TIdSoapLoadITIEvent = procedure(ASender: TIdSoapITIProvider; AITI : TIdSoapITI) of object; </pre>
		<pre>&nbsp; property OnLoadITI : TIdSoapLoadITIEvent;</pre>
		<p>Summary: Manually load ITI. This is generally reserved for when the application wishes a single interface to load multiple 
                   ITI sources, This is useful in suites of applications which share different combinations of ITI's. If you wish to load
                   multiple ITI's, just create the appropriate ITI reader, give it a stream, and ask it to read the stream. You do not need
                   to reset the state of the ITI - just keep reading into it. The best way to manage this is to set the ITISource to islManual,
                   assign the OnLoadITI event to the procedure LoadMultipleResources on the ITIProvider, and then multiple resources will be loaded
                   from the comma delimited list in the ITIResourceName property
		</p>
		<p><br>
			&nbsp;
		</p>
		<h4>WSDL generation</h4>
		<p>Where the type <a href="TIdSoapRawXML.htm">TIdSoapRawXML</a> is used, 2 events 
			will be used to get the schema declaration for the RawXMl that is otherwise not 
			described to IndySoap. Refer to <a href="file:///C:/indy/SOAP/Doco/source/TIdSoapRawXML.htm">
				TIdSoapRawXML</a></p>
		<p>for further documentation<br>
			<br>
		</p>
		<p><span style="FONT-FAMILY: courier new,courier,monospace">&nbsp;
TIdGetSchemaTypeEvent = procedure (ASender : TIdSoapITIProvider; const
APath : string; ADocLit : boolean;</span><br style="FONT-FAMILY: courier new,courier,monospace">
			<span style="FONT-FAMILY: courier new,courier,monospace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
var VHandled : boolean; var VNamespace, VTypeName : string) of object;<br>
</span><br style="FONT-FAMILY: courier new,courier,monospace">
			<span style="FONT-FAMILY: courier new,courier,monospace">&nbsp;
property OnGetSchemaType : TIdGetSchemaTypeEvent;</span><br style="FONT-FAMILY: courier new,courier,monospace">
		</p>
		<p><br>
			parameters:<br>
		</p>
		<table cellpadding="2" cellspacing="0" border="1" style="WIDTH: 50%; TEXT-ALIGN: left" id="Table1">
			<tbody>
				<tr>
					<td><span style="FONT-FAMILY: courier new,courier,monospace">ASender </span></td>
					<td>The ITIProvider that this event comes from<br>
					</td>
				</tr>
				<tr>
					<td><span style="FONT-FAMILY: courier new,courier,monospace">APath </span></td>
					<td>Identifies which TIdSoapRawXML this event is associated with<br>
					</td>
				</tr>
				<tr>
					<td><span style="FONT-FAMILY: courier new,courier,monospace">ADocLit </span></td>
					<td>Whether this WSDL describes a doc|lit interface (though this is not expected to 
						make any difference to how you declare types)<br>
					</td>
				</tr>
				<tr>
					<td><span style="FONT-FAMILY: courier new,courier,monospace">VHandled </span></td>
					<td>set this to true if you assign a value to the next 2 properties<br>
					</td>
				</tr>
				<tr>
					<td><span style="FONT-FAMILY: courier new,courier,monospace">VNamespace</span></td>
					<td>namespace &nbsp;for the type.
						<br>
					</td>
				</tr>
				<tr>
					<td><span style="FONT-FAMILY: courier new,courier,monospace">VTypeName </span></td>
					<td>Name for the type<br>
					</td>
				</tr>
			</tbody>
		</table>
		<p>You do not need to provide a type name - if you don't then the type must be 
			declared in-line in the next event, or indysoap can populate it with the 
			standard untyped XML description. You can choose any combination of namespace 
			and name, as long as you don't collide with some other type declaration of 
			interest<br>
		</p>
		<p><br>
		</p>
		<p style="FONT-FAMILY: courier new,courier,monospace">&nbsp; TIdGetSchemaEvent = 
			procedure (ASender : TIdSoapITIProvider; const APath, ANameSpace, ATypeName : 
			string;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			ANamespaces : TIdSoapXmlNamespaceSupport;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			var VHandled : boolean; AElement, ATypes : TdomElement) of object;<br>
		</p>
		<p style="FONT-FAMILY: courier new,courier,monospace">&nbsp; property OnGetSchema : 
			TIdGetSchemaEvent;<br>
		</p>
		<p><br>
		</p>
		<table cellpadding="2" cellspacing="0" border="1" style="WIDTH: 50%; TEXT-ALIGN: left" id="Table2">
			<tbody>
				<tr>
					<td>ASender
					</td>
					<td>The ITIProvider that this event comes from</td>
				</tr>
				<tr>
					<td>APath</td>
					<td>Identifies which TIdSoapRawXML this event is associated with</td>
				</tr>
				<tr>
					<td>ANameSpace</td>
					<td>namespace of type if given in OnGetSchemaType event<br>
					</td>
				</tr>
				<tr>
					<td>ATypeName
					</td>
					<td>name of type if given in OnGetSchemaType event</td>
				</tr>
				<tr>
					<td>ANamespaces
					</td>
					<td>handle to the namespace services for the message writing environment<br>
					</td>
				</tr>
				<tr>
					<td>VHandled
					</td>
					<td>set this to true if you handled this event<br>
					</td>
				</tr>
				<tr>
					<td>AElement</td>
					<td>the element that refers to the content</td>
				</tr>
				<tr>
					<td>ATypes
					</td>
					<td>the root element for the types section of the wsdl, which will contain multiple 
						schema elements, for different target namespaces<br>
					</td>
				</tr>
			</tbody>
		</table>
		<p><br>
			If ANamespace and ATypeName are blank, and you leave Vhandled as false, 
			IndySoap will insert a standard untyped XML schema for the element.<br>
			<br>
		</p>
	</body>
</html>
